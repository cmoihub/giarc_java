package ass4;

//https://www.youtube.com/watch?v=FNeL18KsWPc
//http://www.algolist.net/Data_structures/Binary_search_tree

public class BSTDictionary<E,K extends Sortable> implements Dictionary<E,K> {

	BSTNode <E, K> root;
	BSTNode <E, K> curr;
	
	public BSTDictionary(){
		root = null;
	}//Default constructor
	
	public BSTDictionary(BSTNode <E, K> head){
		root = head;
	}// construct BST  with given node as root
	
	@Override
	public void insert(K key, E element) {
		BSTNode<E,K> newNode = new BSTNode <> (key, element,null,null);
//		BSTNode <E, K> curr = root;
		if(root == null){
			root = newNode;
			curr = root;
		}//empty tree
		else if (curr.getKey().compareTo(newNode.getKey()) != 0){
//			if(curr.getKey().compareTo(newNode.getKey()) == 0){
//				return;//duplicate
//			}
			else if (curr.getKey().compareTo(newNode.getKey()) < 0){
				if (curr.getLeft() == null) {
					curr.setLeft(newNode);
				}//insert if current node has no left child
				else{
					curr = curr.getLeft();//traverse leftwise
					insert (key,element);//handle left child
				}
			}//inserting on the left
			
			else if (curr.getKey().compareTo(newNode.getKey()) > 0){
				if (curr.getRight() == null){
					curr.setRight(newNode);
				}//insert if current node has no right child
				else{
					curr = curr.getRight();//traverse rightwise
					insert (key,element);//handle right child
				}
			}//inserting on the right
		}//find a place in the tree to insert it
	}//insert a key-value pair into the binary search tree
	
	@Override
	public E search(K key) {
		BSTNode<E,K> copy;
		//System.out.println(curr.getKey());
		if(curr == null){
			curr = root;
			return null;
		}//unavailable key-value pair 
		if(curr.getKey().compareTo(key) == 0){
			/*BSTNode<E,K> */copy = new BSTNode <> (curr.getKey(), curr.getElement(), curr.getLeft(), curr.getRight());
			curr = root;
			return copy.getElement();
			}//if key is the one at the current node
		else if(curr.getKey().compareTo(key) < 0){
			curr = curr.getLeft();
			return search(key);
			}//left child check

		else if(curr.getKey().compareTo(key) > 0){
			curr = curr.getRight();
			return search(key);
			}//right child check
		return null;
	}//return the entry corresponding to a specified Key k
	
	@Override
	public void delete(K key) {
		curr = root;
		BSTNode<E, K> parent = null/*useful for special cases*/, 
				target = null/*node to delete*/;
		if(key!=null)//null check to makesure the key is not a null value
		{
			while(curr!=null)//search for element to delete
			{
				if(key.compareTo(curr.getKey())==0)//key is found target is set to current node
				{
					target = curr;
					break;
				}
				
				else if(key.compareTo(curr.getKey())<0)//key is less then currentnode key. current node is set so currentnode->currentnode.left
				{
					parent = curr;
					curr=curr.getLeft();
				}
				else//key is greater then currentnode key currentnode->currentnode.right
				{
					parent=curr;
					curr = curr.getRight();
				}
			}
			if(target!=null)//used to make sure target has been found if targ==null element DNE in tree
			{
				
				if(target.getLeft()!=null&&target.getRight()!=null)//if the target has two subnodes
				{
					BSTNode<E,K> tempnode = findMin(target.getRight());//finds the minimum value in the right tree
					//instead of deleting the target node the key/element values are exchanged for the minimum value found in the right subtree
					target.key = tempnode.getKey();
					target.element = tempnode.getElement();
					tempnode = null;//sets minimum value from right tree to null(deletes that node)
					
				}
				else if(target.getLeft()!=null&&target.getRight()==null)//if node being deleted has only a left child node
				{
					//sets the left node of the parentnode(the element to be deleted) to the only childnode of the node to be deleted
					parent.setLeft(target.getLeft());
					target=null;//deletes the node
				}
				else if(target.getLeft()==null&&target.getRight()!=null)//if node being deleted only has a right node
				{
					//sets the rightnode of the parentnode(the element to be deleted)to the only childnode of the node to be deleted
					parent.setRight(target.getRight());
					target=null;//deletes the node
				}
				else//the node does not have any children
				{
					target = null;//deletes node
				}
			}	
		}	
	}

	public BSTNode<E,K> findMin (BSTNode<E,K> node){
		while(node.getLeft()!=null){//while there is still a left node keep going left
            node = node.getLeft();
        }
        return node;//leftmost node found
	}//used to find the left most node of the tree
	
	public BSTNode<E, K> rightMost(BSTNode<E, K> node) {
        if(node.getLeft() == null) return node.getRight();
        else node.setLeft(rightMost(node.getLeft()));
        return node;
    }
	
	@Override
	public void printTree() {
		printRecursive(root);
	}//print the binary search tree
	
	public void printRecursive(BSTNode <E,K> node){
		if(node!=null){
            printRecursive(node.getLeft());//go through nodes attached to current left node
            System.out.println("key: " + node.getKey().toString() + 
                " element: " + node.getElement().toString());
            printRecursive(node.getRight());//go through nodes attached to current right node      
        }
	}

	@Override
	public int depth() {
		return depthRecursive(root);
	}//return the depth of the binary search tree
	
	public int depthRecursive(BSTNode<E,K> node){
		if (node == null) return 0;//finished traversing
		return 1 + Math.max(depthRecursive(node.getLeft()), depthRecursive(node.getRight()));
	}//recursively determine depth of tree by traversing comparing left and right nodes
}
