
package ass4;

//https://www.youtube.com/watch?v=FNeL18KsWPc
//http://www.algolist.net/Data_structures/Binary_search_tree

public class BSTDictionary<E,K extends Sortable> implements Dictionary<E,K> {

	BSTNode <E, K> root;
	BSTNode <E, K> curr;
	
	public BSTDictionary(){
		root = null;
	}//Default constructor
	
	public BSTDictionary(BSTNode <E, K> head){
		root = head;
	}// construct BST  with given node as root
	
	@Override
	public void insert(K key, E element) {
		BSTNode<E,K> newNode = new BSTNode <> (key, element,null,null);
		if(root == null){
			root = newNode;
			curr = root;
		}//empty tree
		else if (curr.getKey().compareTo(newNode.getKey()) != 0){
			if (curr.getKey().compareTo(newNode.getKey()) < 0){
				if (curr.getLeft() == null) {
					curr.setLeft(newNode);
					curr = root;
				}//insert if current node has no left child
				else/*compare key with left child's key*/{
					curr = curr.getLeft();//traverse leftwise
					insert (key,element);//handle left child
				}
			}//inserting on the left
			
			else if (curr.getKey().compareTo(newNode.getKey()) > 0){
				if (curr.getRight() == null){
					curr.setRight(newNode);
					curr = root;
				}//insert if current node has no right child
				else/*compare key with right child's key*/{
					curr = curr.getRight();//traverse rightwise
					insert (key,element);//handle right child
				}
			}//inserting on the right
		}//find a place in the tree to insert it
		return;
	}//insert a key-value pair into the binary search tree
	
	@Override
	public E search(K key) {
		BSTNode<E,K> copy;
		//System.out.println(curr.getKey());
		if(curr == null){
			curr = root;
			return null;
		}//unavailable key-value pair 
		if(curr.getKey().compareTo(key) == 0){
			/*BSTNode<E,K> */copy = new BSTNode <> (curr.getKey(), curr.getElement(), curr.getLeft(), curr.getRight());
			curr = root;
			return copy.getElement();
			}//if key is the one at the current node
		else if(curr.getKey().compareTo(key) < 0){
			curr = curr.getLeft();
			return search(key);
			}//left child check

		else if(curr.getKey().compareTo(key) > 0){
			curr = curr.getRight();
			return search(key);
			}//right child check
		return null;
	}//return the entry corresponding to a specified Key k
	
	@Override
	public void delete(K key) {
		//curr = root; doesn't work this way for some reason? scoping issue?
		BSTNode<E, K> parent = null/*useful for special cases*/, 
				target = null/*node to delete*/,
				curr = root;
		//if(key!=null){
			while(curr!=null){
				if(key.compareTo(curr.getKey())==0)	{
					target = curr;
					break;
				}//target is current node
				
				else if(key.compareTo(curr.getKey())<0) {
					parent = curr;
					curr=curr.getLeft();
				}//check left child
				
				else
				{
					parent=curr;
					curr = curr.getRight();
				}//check right child
			}//search for element to delete
			if(target!=null) {
				if(target.getLeft()!=null&&target.getRight()!=null)
				{
					//BSTNode<E,K> newNode = new BSTNode <> (key, element,null,null);
					 BSTNode<E,K> tempNode = findMin(target.getRight());//finds the minimum value in the right tree
					 tempNode = new BSTNode<E,K> (null, null, null, null) -> {
							while(target.getRight().getLeft()!=null){//while there is still a left node keep going left
					            target = target.getLeft();
					        }
							tempNode.key = target.key;
							tempNode.setElement(target.getElement());
							tempNode.setLeft(target.getLeft());
							tempNode.setRight(target.getRight());
//					        //return target;
						};
					 tempNode = /*(BSTNode<E,K> */ node ->{
						 while(node.getRight().getLeft()!=null){//while there is still a left node keep going left
					            node = target.getLeft();
					        }
							tempNode.key = node.key;
							tempNode.setElement(node.getElement());
							tempNode.setLeft(node.getLeft());
							tempNode.setRight(node.getRight());
					        return node; 
					 };
					//instead of deleting the target node the key/element values are exchanged for the minimum value found in the right subtree
					target.key = tempNode.getKey();
					target.element = tempNode.getElement();
					tempNode = null;//sets minimum value from right tree to null(deletes that node)
				}//2 children case
				else if(target.getLeft()!=null&&target.getRight()==null)
				{
					//sets the left node of the parentnode(the element to be deleted) to the only childnode of the node to be deleted
					parent.setLeft(target.getLeft());
					target=null;//deletes the node
				}//left child case
				else if(target.getLeft()==null&&target.getRight()!=null)
				{
					//sets the rightnode of the parentnode(the element to be deleted)to the only childnode of the node to be deleted
					parent.setRight(target.getRight());
					target=null;//deletes the node
				}//right child case
				else//the node does not have any children
				{
					target = null;//deletes node
				}
			}//assert that target has been found	
		//}	
	}

	public BSTNode<E,K> findMin (BSTNode<E,K> node){
		while(node.getLeft()!=null){//while there is still a left node keep going left
            node = node.getLeft();
        }
        return node;//leftmost node found
	}//used to find the left most node of the tree
	
	public BSTNode<E, K> rightMost(BSTNode<E, K> node) {
        if(node.getLeft() == null) return node.getRight();
        else node.setLeft(rightMost(node.getLeft()));
        return node;
    }
	
	@Override
	public void printTree() {
		printRecursive(root);
	}//print the binary search tree
	
	public void printRecursive(BSTNode <E,K> node){
		if(node!=null){
            printRecursive(node.getLeft());//go through nodes attached to current left node
            System.out.println("key: " + node.getKey().toString() + 
                " element: " + node.getElement().toString());
            printRecursive(node.getRight());//go through nodes attached to current right node      
        }
	}

	@Override
	public int depth() {
		return depthRecursive(root);
	}//return the depth of the binary search tree
	
	public int depthRecursive(BSTNode<E,K> node){
		if (node == null) return 0;//finished traversing
		return 1 + Math.max(depthRecursive(node.getLeft()), depthRecursive(node.getRight()));
	}//recursively determine depth of tree by traversing comparing left and right nodes
}
