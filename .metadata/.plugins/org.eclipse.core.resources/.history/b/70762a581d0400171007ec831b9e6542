package ass4;
//N_h = 1 + N_h1 (right) + N_h2 (left)
public class AVLDictionary<E,K extends Sortable> implements Dictionary<E,K> {

	AVLNode <E, K> root;
	//AVLNode <E, K> curr;
	
	public AVLDictionary(){
		root = null;
	}//Default constructor
	
	public AVLDictionary(AVLNode <E, K> head){
		root = head;
	}// construct AVL  with given node as root
	
	@Override
	public E search(K key) {
		AVLNode <E, K> curr = root;
		
		if(curr == null)
		{
			curr = root;
			return null;
		}// key not found
		//System.out.println(curr.getKey());
		if(curr.getKey().compareTo(key) == 0){
			return curr.getElement();
		}//if key is the one at the current node
		
		else if(curr.getKey().compareTo(key) < 0){
			return search(curr.getLeft().getKey());
		}//left child check
		
		else if(curr.getKey().compareTo(key) > 0){
			return search(curr.getRight().getKey());
		}//right child check
		else return null;
	}//return the entry corresponding to a specified Key k

	@Override
	public void insert(K key, E element) {
		AVLNode<E,K> temp = new AVLNode<E, K>(key, element,null,null,0);
		AVLNode <E, K> curr = root;
		if(curr == null){
			curr = temp;
			//curr = root;
		}//empty tree
		//search(key);//overwrite duplicates
		
		if (curr.getKey().compareTo(key) > 0){
			if (curr.getRight() == null) root.setRight(temp);
			else insert (key,element);
		}
		
		if (curr.getKey().compareTo(key) < 0){
			if (curr.getLeft() == null) curr.setLeft(temp);
			else insert (key,element);
		}
	}//insert a key-value pair into the binary search tree

	@Override
	public void delete(K key) {
		search(key);//overwrite duplicates
		AVLNode <E,K> curr = root;
		if(key.compareTo(curr.getKey()) == 0){
            if(curr.getLeft()==null && curr.getRight() == null){
            	curr=null;
            }//no children
            else if(curr.getLeft()!=null && curr.getRight() == null){
                curr.setRight(null);
            }//left child
            else if(curr.getLeft()==null && curr.getRight() != null){
                curr.setLeft(null);
            }//right child
            else if(curr.getLeft()!=null && curr.getRight()!=null){
                AVLNode <E,K> leftMostNode=leftMost(curr);
                AVLNode <E,K> oldLeft = curr.getLeft();
                leftMostNode.setRight(rightMost(curr.getRight()));
                leftMostNode.setLeft(oldLeft);
                delete(leftMostNode.getKey());
            }//2 children
            delete(curr.getKey());
          }//current node is the one to be deleted
        else if(key.compareTo(curr.getKey()) < 0){
            if(curr.getLeft()!=null)delete(curr.getLeft().getKey());
        }//need to traverse to the left to find key-value pair to delete
        else delete(curr.getRight().getKey());//need to traverse to the right to find key-value pair to delete
        delete(curr.getKey());
	}//remove the entry in the binary search tree corresponding to key K

	public AVLNode<E,K> leftMost (AVLNode<E,K> node){
		while(node.getLeft()!=null){//while there is still a left node keep going left
            node = node.getLeft();
        }
        return node;//leftmost node found
	}//used to find the left most node of the tree
	
	public AVLNode<E, K> rightMost(AVLNode<E, K> node) {
        if(node.getLeft() == null) return node.getRight();
        else node.setLeft(rightMost(node.getLeft()));
        return node;
    }
	
	@Override
	public void printTree() {
		printRecursive(root);
	}//print the binary search tree
	
	public void printRecursive(AVLNode <E,K> node){
		if(node!=null){
            printRecursive(node.getLeft());//go through nodes attached to current left node
            System.out.println("key: " + node.getKey().toString() + 
                " element: " + node.getElement().toString());
            printRecursive(node.getRight());//go through nodes attached to current right node      
        }
	}

	@Override
	public int depth() {
		return depthRecursive(root);
	}//return the depth of the binary search tree
	
	public int depthRecursive(AVLNode<E,K> node){
		if (node == null) return 0;//finished traversing
		return 1 + Math.max(depthRecursive(node.getLeft()), depthRecursive(node.getRight()));
	}//recursively determine depth of tree by traversing comparing left and right nodes
}
