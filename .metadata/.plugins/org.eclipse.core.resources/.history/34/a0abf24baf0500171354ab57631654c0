package ass4;

/**
 * @author Craig Isesele
 * @version Assignment 4
 */
public class TestBrief<E, K extends Sortable> implements Dictionary<E, K>{
    protected BSTNode<E,K> node;
    protected int zero = 0;//used in compareTo method
    public E search(K key) {
        //check root of tree or current node
        //both cases imply that the search cannot be carried out
        //empty tree, empty search criteria
        //if(key==null || node == null)return null;
        if(node.getKey().compareTo(key)==zero)return node.getElement();
        else if(node.getKey().compareTo(key)<zero)//check left child
            return search(node.getLeft().getKey());
        else if(node.getKey().compareTo(key)>zero)//check right child
            return search(node.getRight().getKey());
        //else
        return null;// for any other possible case return null
    }// search for an entry with key KEY and return the object

    public void insert(K key, E element){
        BSTNode<E,K> newNode=new BSTNode<E, K>(key, element,null,null);
        if(node == null)node=newNode;//empty tree
        search(key);//Duplicates are overwritten
        if(node.getKey().compareTo(key)>zero){
           if(node.getRight()==null)node.setRight(newNode);
           else insert(key,element);
          }
        else if(node.getKey().compareTo(key)<zero){
           if(node.getLeft()==null)node.setLeft(newNode);
           else insert(key,element);
          }
          else System.out.println("Please try again");
    }// insert a key-value pair into the dictionary

    public BSTNode<E,K> leftMost(BSTNode<E,K> node){
        while(node.getLeft()!=null){
            node = node.getLeft();
        }
        return node;
    }
    
    public BSTNode<E, K> rightChild(BSTNode<E, K> node) {
        if(node.getLeft() == null) return node.getRight();
        else node.setLeft(rightChild(node.getLeft()));
        return node;
    }
    
    public void delete(K key) {
        search(key);
        if(key.compareTo(node.getKey())==zero){
            if(node.getLeft()==null && node.getRight()==null)//leaf
                node=null;
            else if(node.getLeft()!=null && node.getRight()==null){
                node.setRight(null);
            }//left child
            else if(node.getLeft()==null && node.getRight()!=null){
                node.setLeft(null);
            }//right child
            //2 kids big family
            else if(node.getLeft()!=null && node.getRight()!=null){
                BSTNode <E,K> leftMostNode=leftMost(node);
                BSTNode <E,K> oldLeft = node.getLeft();
                leftMostNode.setRight(rightChild(node.getRight()));
                leftMostNode.setLeft(oldLeft);
                delete(leftMostNode.getKey());
            }
            delete(node.getKey());
          }
        else if(key.compareTo(node.getKey())==zero){
            if(node.getLeft()!=null)delete(node.getLeft().getKey());
        }else delete(node.getRight().getKey());
        delete(node.getKey());
    }// delete an entry with key KEY

    public void printRecursive(BSTNode<E,K> node){
        if(node!=null){
            printRecursive(node.getLeft());
            System.out.println("key: " + node.getKey().toString() + 
                " element: " + node.getElement().toString());
            printRecursive(node.getRight());      
        }
    }
    //feels unnecessary but I have to comply with the 
    //dictionaryTest's convention for printing
    public void printTree(){
        printRecursive(node);
       }    // print the Dictionary in sorted order (as determined by the keys)
    // return the depth of the underlying tree
    public int depth(){
        //if(node!=null) return Math.max()
        return zero;
       }
}